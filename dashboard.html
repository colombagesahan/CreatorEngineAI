// 1. IMPORTS (FFmpeg + Alpine)
import { FFmpeg } from "https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/esm/index.js";
import { fetchFile, toBlobURL } from "https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/esm/index.js";
import Alpine from "https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/module.esm.js";

// --- PROTECTION CODE START ---
(function(){
    var allowedDomain = "colombagesahan.github.io"; 
    // Allow localhost/127.0.0.1 for testing, otherwise block
    if(window.location.hostname !== allowedDomain && 
       window.location.hostname !== "127.0.0.1" && 
       window.location.hostname !== "localhost" &&
       window.location.hostname !== "") { // Allow empty for file:// testing if needed
        document.body.innerHTML = "<div style='display:flex;height:100vh;align-items:center;justify-content:center;background:black;color:red;font-family:sans-serif;text-align:center;'><h1>‚ö†Ô∏è THEFT DETECTED</h1></div>";
        throw new Error("Execution Stopped");
    }
})();
// --- PROTECTION CODE END ---

const origWarn = console.warn;
console.warn = (...args) => {
    if (args[0] && typeof args[0] === 'string' && args[0].includes('cdn.tailwindcss.com')) return;
    origWarn.apply(console, args);
};

// Expose function globally
window.videoApp = function() {
    return {
        step: 1, mode: 'quick', format: '9:16', topic: '', targetCountry: 'USA',
        loading: false, processing: false, progressText: '',
        
        // Video State
        videoURL: null, 
        apiKey: 'AIzaSyBPoOd87sG2LpICsMk6mi7Aeg9nvKTWq5c',

        // FFmpeg State
        ffmpeg: null,
        converting: false,
        mp4URL: null,
        
        scenes: [], audioCtx: null, dest: null,
        mediaRecorder: null, audioChunks: [], recordingIndex: null, recStartTime: 0,
        validModel: null, bgMusicFile: null, bgMusicBuffer: null,
        bgMusicNode: null,
        
        voiceVol: 1.0, musicVol: 0.15, useBgMusic: false,
        metadataLoading: false, generatedTitle: '', generatedDescription: '',

        animState: { img: null, video: null, text: "", color: "#fff", zoom: 1.0, textY: 100, textAlpha: 0, fontSize: 80, animation: 'fade', progress: 0 },

        init() {
            const cvs = document.getElementById('videoCanvas');
            if(!cvs) return; // guard: don't crash if canvas missing
            if(this.format === '9:16') { cvs.width = 1080; cvs.height = 1920; }
            else { cvs.width = 1920; cvs.height = 1080; }
        },

        cleanup() {
            this.scenes.forEach(s => {
                if(s.media_url && s.media_url.startsWith('blob:')) URL.revokeObjectURL(s.media_url);
            });
            if(this.videoURL && this.videoURL.startsWith && this.videoURL.startsWith('blob:')) URL.revokeObjectURL(this.videoURL);
            if(this.mp4URL && this.mp4URL.startsWith && this.mp4URL.startsWith('blob:')) URL.revokeObjectURL(this.mp4URL);
        },

        reset() { 
            this.cleanup();
            this.step = 1; this.topic = ''; this.scenes = []; this.bgMusicFile = null; 
            this.generatedTitle = ''; this.generatedDescription = '';
            this.mp4URL = null; this.converting = false;
        },

        // ensure audio context + destination exist (call on demand)
        async ensureAudio() {
            if (!this.audioCtx) {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioCtx = new AudioContext();
                } catch(e) {
                    console.error("AudioContext not available", e);
                    this.audioCtx = null;
                }
            }
            if (this.audioCtx && !this.dest) {
                try {
                    this.dest = this.audioCtx.createMediaStreamDestination();
                } catch(e) {
                    console.error("Could not create MediaStreamDestination", e);
                    this.dest = null;
                }
            }
            if (this.audioCtx && this.audioCtx.state === 'suspended') {
                try { await this.audioCtx.resume(); } catch(e) { /* ignore */ }
            }
        },

        // --- FFMPEG CONVERSION LOGIC ---
        async convertToMP4() {
            if (!this.videoURL) return alert("No video to convert!");
            this.converting = true;

            try {
                if (!this.ffmpeg) {
                    // Depending on the FFmpeg wrapper version the constructor may differ.
                    // We try to construct, but if your imported API differs you may need to adjust imports.
                    try {
                        this.ffmpeg = new FFmpeg();
                    } catch (e) {
                        console.warn("FFmpeg constructor failed - check import/API of ffmpeg.wasm", e);
                        throw e;
                    }

                    const baseURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/esm';
                    await this.ffmpeg.load({
                        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                    });
                }

                // fetch the blob data (safe for blob: URLs)
                let fileData;
                if (typeof this.videoURL === 'string' && this.videoURL.startsWith('blob:')) {
                    const resp = await fetch(this.videoURL);
                    const ab = await resp.arrayBuffer();
                    fileData = new Uint8Array(ab);
                } else {
                    // fetchFile helper also works for File/ArrayBuffer; fallback to fetch
                    fileData = await fetchFile(this.videoURL);
                }

                await this.ffmpeg.writeFile('input.webm', fileData);

                await this.ffmpeg.exec([
                    '-i', 'input.webm',
                    '-c:v', 'libx264',
                    '-preset', 'ultrafast', 
                    '-pix_fmt', 'yuv420p',
                    'output.mp4'
                ]);

                const data = await this.ffmpeg.readFile('output.mp4');
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                if (this.mp4URL && this.mp4URL.startsWith && this.mp4URL.startsWith('blob:')) URL.revokeObjectURL(this.mp4URL);
                this.mp4URL = URL.createObjectURL(blob);

            } catch (error) {
                console.error("Conversion Error:", error);
                alert("Conversion failed. Check console for details (FFmpeg import/API may differ).");
            } finally {
                this.converting = false;
            }
        },

        // --- EXISTING LOGIC ---

        async getValidModel() {
            if (this.validModel) return this.validModel;
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${this.apiKey}`);
                const data = await res.json();
                const good = data.models?.find(m => m.name.includes("gemini-1.5-flash") || m.name.includes("gemini-pro"));
                this.validModel = good ? good.name.replace("models/", "") : "gemini-1.5-flash";
                return this.validModel;
            } catch (e) { 
                console.warn("Model lookup failed, using default", e);
                return "gemini-1.5-flash"; 
            }
        },

        async generateTrendingTopic() {
            this.loading = true;
            try {
                const model = await this.getValidModel();
                const prompt = `Give ONE viral YouTube Short topic for ${this.targetCountry}. Return text only.`;
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await res.json();
                this.topic = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
            } catch(e) { 
                console.error("Trend Error", e);
                alert("Trend Error");
            }
            this.loading = false;
        },

        async generateScript() {
            if(!this.topic) return alert("Enter a topic!");
            this.loading = true;
            this.init(); 

            try {
                await this.ensureAudio();
            } catch(e) { /* keep going without audio */ }

            const model = await this.getValidModel();
            const prompt = `Act as a Viral Video Director. Target: ${this.targetCountry}. Topic: "${this.topic}"
            Create 3 scenes. Scene 1: Hook (< 8 words). Scenes 2-3: Content (< 12 words).
            For 'color_hex': Pick NEON color (#FF0055, #00CCFF, #00FF99, #FFD700).
            Return JSON: { "scenes": [ { "text": "...", "color_hex": "..." } ] }`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                let raw = (data.candidates?.[0]?.content?.parts?.[0]?.text || "").replace(/```json/g, '').replace(/```/g, '').trim();
                if (!raw) throw new Error("Empty AI response");
                const json = JSON.parse(raw);
                
                this.scenes = json.scenes.map((s, i) => ({
                    text: s.text, media_url: null, media_type: 'none', image_source: 'Empty',
                    type: i === 0 ? 'hook' : 'content',
                    color: s.color_hex || '#FFD700',
                    fontSize: 80, duration: 5, audio_blob: null, isWriting: false,
                    recDuration: 0, animation: 'fade'
                }));
                this.step = 2;
            } catch(e) { 
                console.error("AI script failed", e);
                alert("AI Error. Try again.");
            } finally {
                this.loading = false;
            }
        },

        addScene() { this.scenes.push({ text: "", media_url: null, media_type: 'none', image_source: 'Empty', type: 'content', color: '#00CCFF', fontSize: 80, duration: 5, audio_blob: null, isWriting: false, recDuration: 0, animation: 'fade' }); },
        addOutro() { this.scenes.push({ text: "Thanks for watching! Subscribe üîî", media_url: null, media_type: 'none', image_source: 'Empty', type: 'outro', color: '#00FF99', fontSize: 80, duration: 5, audio_blob: null, isWriting: false, recDuration: 0, animation: 'zoom' }); },

        async autoWriteScene(index) {
            this.scenes[index].isWriting = true;
            const model = await this.getValidModel();
            const prompt = `Topic: "${this.topic}". Write ONE short script line (max 10 words, emoji).`;
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await res.json();
                this.scenes[index].text = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "Error.";
            } catch(e) { 
                console.error("autoWriteScene failed", e);
                this.scenes[index].text = "Error."; 
            }
            this.scenes[index].isWriting = false;
        },

        handleUpload(event, index) {
            const file = event.target.files[0];
            if(file) {
                if(this.scenes[index].media_url) URL.revokeObjectURL(this.scenes[index].media_url);
                this.scenes[index].media_url = URL.createObjectURL(file);
                this.scenes[index].media_type = file.type.startsWith('video') ? 'video' : 'image';
                this.scenes[index].image_source = 'Upload';
            }
        },
        
        handleMusicUpload(event) {
            const file = event.target.files[0];
            if(file) {
                this.bgMusicFile = file; this.useBgMusic = true;
                const reader = new FileReader();
                reader.onload = async (e) => { 
                    try {
                        await this.ensureAudio();
                        if (this.audioCtx) {
                            // note: decodeAudioData returns a promise in modern browsers
                            this.bgMusicBuffer = await this.audioCtx.decodeAudioData(e.target.result);
                        }
                    } catch(err) {
                        console.error("Failed to decode BG music", err);
                        this.bgMusicBuffer = null;
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        },

        removeScene(index) { 
            if(this.scenes[index]?.media_url) {
                try { URL.revokeObjectURL(this.scenes[index].media_url); } catch(e) {}
            }
            if(this.scenes.length > 1) this.scenes.splice(index, 1); 
        },

        playGuide(text) {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text || "Text missing");
            u.lang = "en-US"; u.rate = 0.9; u.volume = this.voiceVol;
            window.speechSynthesis.speak(u);
        },

        async startRecording(index) {
            window.speechSynthesis.cancel(); this.recordingIndex = index; this.audioChunks = []; this.recStartTime = Date.now();
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.mediaRecorder = new MediaRecorder(stream);
                this.mediaRecorder.ondataavailable = e => this.audioChunks.push(e.data);
                this.mediaRecorder.start();
            } catch(e) { console.error("Mic access denied", e); alert("Mic Access Denied."); }
        },

        stopRecording(index) {
            if(this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                // set handler before stopping to avoid race
                this.mediaRecorder.onstop = () => {
                    const blob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    this.scenes[index].audio_blob = blob;
                    const duration = (Date.now() - this.recStartTime) / 1000;
                    this.scenes[index].recDuration = duration.toFixed(1);
                    this.scenes[index].duration = duration.toFixed(1); 
                    this.recordingIndex = null;
                    try { this.mediaRecorder.stream.getTracks().forEach(track => track.stop()); } catch(e) {}
                };
                try { this.mediaRecorder.stop(); } catch(e) { console.warn("error stopping mediaRecorder", e); }
            }
        },

        playRecording(index) { if(this.scenes[index].audio_blob) new Audio(URL.createObjectURL(this.scenes[index].audio_blob)).play(); },
        
        async generateMetadata() {
            this.metadataLoading = true;
            try {
                const model = await this.getValidModel();
                const prompt = `Act as a YouTube SEO Expert. Target Audience: ${this.targetCountry}. Topic: "${this.topic}". Generate: 1. A viral, high-CTR Title for a YouTube Short (max 60 chars). 2. A human-written, engaging Description (max 100 words) including 3 hashtags. Return strictly valid JSON format: { "title": "...", "description": "..." }`;
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await res.json();
                let raw = (data.candidates?.[0]?.content?.parts?.[0]?.text || "").replace(/```json/g, '').replace(/```/g, '').trim();
                const json = JSON.parse(raw);
                this.generatedTitle = json.title || "";
                this.generatedDescription = json.description || "";
            } catch(e) { 
                console.error("generateMetadata failed", e);
                this.generatedTitle = "üî• Amazing " + this.topic + " #Shorts";
                this.generatedDescription = "Check out this incredible video! #Viral #Trending";
            } finally {
                this.metadataLoading = false;
            }
        },

        async startRendering() {
            // require visuals for scenes (except outros)
            const missingImgs = this.scenes.some(s => !s.media_url && s.type !== 'outro');
            if(missingImgs) return alert("‚ö†Ô∏è Please upload visuals for all scenes!");

            this.processing = true;
            await this.ensureAudio(); // make sure audio context + dest exist

            const canvas = document.getElementById('videoCanvas');
            if (!canvas) { alert("Canvas element missing (#videoCanvas)"); this.processing = false; return; }
            const ctx = canvas.getContext('2d');
            const assets = [];

            for(let i=0; i<this.scenes.length; i++) {
                this.progressText = `Preparing Scene ${i+1}/${this.scenes.length}`;
                const s = this.scenes[i];
                try {
                    if(s.media_type === 'video') {
                        const v = document.createElement('video');
                        v.src = s.media_url; v.muted = true; v.loop = true;
                        await new Promise((resolve, reject) => { v.onloadedmetadata = () => resolve(); v.onerror = () => reject(); v.load(); });
                        assets.push({ type: 'video', el: v });
                    } else {
                        if (!s.media_url) { assets.push({ type: 'placeholder', el: null }); } else {
                            const imgPromise = this.loadImage(s.media_url);
                            const timeoutPromise = new Promise(r => setTimeout(() => r(null), 3000));
                            const img = await Promise.race([imgPromise, timeoutPromise]);
                            if(!img) { assets.push({ type: 'placeholder', el: null }); } else { assets.push({ type: 'image', el: img }); }
                        }
                    }
                } catch(e) { console.warn("asset prepare failed", e); assets.push({ type: 'placeholder', el: null }); }
            }

            if(this.bgMusicBuffer && this.useBgMusic && this.audioCtx && this.dest) {
                try {
                    const s = this.audioCtx.createBufferSource();
                    s.buffer = this.bgMusicBuffer; s.loop = true;
                    const g = this.audioCtx.createGain(); g.gain.value = this.musicVol;
                    s.connect(g); g.connect(this.dest);
                    s.start(0);
                    this.bgMusicNode = s;
                } catch(e) { console.warn("bgMusic start failed", e); }
            }

            this.progressText = "Rendering...";
            // ensure we have a dest to provide audio track; create a silent dest if needed
            if (!this.dest) {
                try {
                    await this.ensureAudio();
                } catch(e) { /* ignore */ }
            }
            if (!this.dest) {
                // create a silent audio track fallback so MediaRecorder has audio track
                const silentCtx = new (window.AudioContext || window.webkitAudioContext)();
                const silentDest = silentCtx.createMediaStreamDestination();
                const osc = silentCtx.createOscillator(); osc.frequency.value = 0;
                const g = silentCtx.createGain(); g.gain.value = 0.0001;
                osc.connect(g); g.connect(silentDest); osc.start();
                this.dest = silentDest;
            }

            const canvasStream = canvas.captureStream(30);
            const osc = this.audioCtx ? (this.audioCtx.createOscillator()) : null;
            if (osc && this.audioCtx) {
                osc.frequency.value = 0; const g = this.audioCtx.createGain(); g.gain.value=0.001; osc.connect(g); g.connect(this.dest); osc.start();
            }

            // Combined stream - video + audio from dest
            const audioTracks = this.dest?.stream?.getAudioTracks() || [];
            const combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...audioTracks]);

            let options = { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: 3500000 };
            if (!MediaRecorder.isTypeSupported('video/webm; codecs=vp9')) { options = { mimeType: 'video/webm', videoBitsPerSecond: 3500000 }; }
            
            const mediaRecorder = new MediaRecorder(combinedStream, options);
            const chunks = [];
            mediaRecorder.ondataavailable = (e) => { if(e.data && e.data.size > 0) chunks.push(e.data); };
            mediaRecorder.start(100);

            let isRendering = true;
            const renderFrame = () => {
                if(!isRendering) return;
                try {
                    ctx.fillStyle = "black"; ctx.fillRect(0,0, canvas.width, canvas.height);
                    if(this.animState.video) {
                         const v = this.animState.video; const vRatio = v.videoWidth / v.videoHeight; const cRatio = canvas.width / canvas.height;
                         let dw, dh, dx, dy;
                         if (vRatio > cRatio) { dh = canvas.height; dw = dh * vRatio; dy = 0; dx = (canvas.width - dw)/2; } else { dw = canvas.width; dh = dw / vRatio; dx = 0; dy = (canvas.height - dh)/2; }
                         ctx.drawImage(v, dx, dy, dw, dh);
                    } else if(this.animState.img) {
                        ctx.save(); const cx = canvas.width/2; const cy = canvas.height/2;
                        ctx.translate(cx, cy); ctx.scale(this.animState.zoom, this.animState.zoom); ctx.translate(-cx, -cy);
                        const imgRatio = this.animState.img.width / this.animState.img.height; const canvasRatio = canvas.width / canvas.height;
                        let dw, dh, dx, dy;
                        if (imgRatio > canvasRatio) { dh = canvas.height; dw = dh * imgRatio; dy = 0; dx = (canvas.width - dw) / 2; } else { dw = canvas.width; dh = dw / imgRatio; dx = 0; dy = (canvas.height - dh) / 2; }
                        ctx.drawImage(this.animState.img, dx, dy, dw, dh); ctx.restore(); this.animState.zoom += 0.0015;
                    } else {
                        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height); grd.addColorStop(0, "#0f0f1a"); grd.addColorStop(1, "#1a1a2e"); ctx.fillStyle = grd; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.width/3, canvas.width/2, canvas.height/2, canvas.height);
                    grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,0.85)"); ctx.fillStyle = grad; ctx.fillRect(0,0, canvas.width, canvas.height);

                    if (this.animState.animation === 'slide') { if(this.animState.textY > 0) this.animState.textY *= 0.9; this.animState.textAlpha = Math.min(this.animState.textAlpha + 0.05, 1); } 
                    else if (this.animState.animation === 'typewriter') { this.animState.progress += 0.5; this.animState.textAlpha = 1; this.animState.textY = 0; } 
                    else { this.animState.textAlpha = Math.min(this.animState.textAlpha + 0.05, 1); this.animState.textY = 0; }
                    
                    ctx.save(); ctx.globalAlpha = this.animState.textAlpha;
                    const boxH = canvas.height * 0.25; const boxY = canvas.height - boxH - 50; 
                    ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.beginPath(); 
                    if(ctx.roundRect) ctx.roundRect(40, boxY, canvas.width - 80, boxH, 30); else ctx.rect(40, boxY, canvas.width - 80, boxH); 
                    ctx.fill();
                    
                    ctx.fillStyle = this.animState.color; ctx.font = `900 ${this.animState.fontSize}px Montserrat, 'Noto Color Emoji'`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    let displayText = this.animState.text || "";
                    if(this.animState.animation === 'typewriter') { const charCount = Math.floor(this.animState.progress); displayText = this.animState.text.substring(0, charCount); }
                    this.wrapText(ctx, displayText, canvas.width/2, boxY + (boxH/2) + this.animState.textY, canvas.width * 0.8, this.animState.fontSize * 1.2);
                    ctx.restore();
                } catch(e) { console.warn("renderFrame error", e); } 
                requestAnimationFrame(renderFrame);
            };
            requestAnimationFrame(renderFrame);

            for (let i = 0; i < this.scenes.length; i++) {
                const scene = this.scenes[i]; const asset = assets[i];
                try {
                    if(asset && asset.type === 'video') { this.animState.video = asset.el; this.animState.img = null; asset.el.play().catch(()=>{}); } 
                    else if (asset && asset.type === 'image') { this.animState.img = asset.el; this.animState.video = null; this.animState.zoom = 1.05; } 
                    else { this.animState.img = null; this.animState.video = null; }
                    this.animState.text = scene.text || ""; this.animState.color = scene.color || '#FFD700'; this.animState.fontSize = parseInt(scene.fontSize) || 80; this.animState.animation = scene.animation || 'fade';
                    this.animState.textY = 100; this.animState.textAlpha = 0; this.animState.progress = 0;
                    const sceneDur = Math.max(1000, parseFloat(scene.duration || 1) * 1000);
                    const p1 = (this.mode === 'creator' && scene.audio_blob) ? this.playBlobAudio(scene.audio_blob) : this.playTTS(scene.text, scene.duration);
                    await Promise.all([p1, new Promise(r => setTimeout(r, sceneDur))]);
                    if(asset && asset.type === 'video') asset.el.pause();
                } catch(e) { console.warn("scene render error", e); }
            }

            await new Promise(r => setTimeout(r, 2000));
            isRendering = false;
            if(this.bgMusicNode) try { this.bgMusicNode.stop(); } catch(e) {}
            mediaRecorder.stop();
            mediaRecorder.onstop = () => {
                this.videoURL = URL.createObjectURL(new Blob(chunks, { type: 'video/webm' }));
                this.processing = false; this.step = 3; this.generateMetadata();
            };
        },

        async loadImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                try { if(url && !url.startsWith('blob:')) img.crossOrigin = "Anonymous"; } catch(e) {}
                img.onload = () => resolve(img);
                img.onerror = () => resolve(null);
                img.src = url;
            });
        },

        async playTTS(text, duration) {
            return new Promise((resolve) => {
                if(!text) return resolve();
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance(text);
                u.rate = 1.0; u.volume = this.voiceVol;
                let resolved = false;
                u.onend = () => { if(!resolved){ resolved = true; resolve(); } };
                u.onerror = () => { if(!resolved){ resolved = true; resolve(); } };
                try { window.speechSynthesis.speak(u); } catch(e) { if(!resolved){ resolved = true; resolve(); } }
                // fallback resolve after a reasonable timeout to prevent hangs
                setTimeout(() => { if(!resolved){ resolved = true; resolve(); } }, Math.min(15000, (text.length * 120) + 2000));
            });
        },

        async playBlobAudio(blob) {
            return new Promise(async (resolve) => {
                try {
                    await this.ensureAudio();
                    if (!this.audioCtx) return resolve();
                    const ab = await blob.arrayBuffer(); const buf = await this.audioCtx.decodeAudioData(ab);
                    const s = this.audioCtx.createBufferSource(); s.buffer = buf; const g = this.audioCtx.createGain(); g.gain.value = this.voiceVol; s.connect(g); g.connect(this.dest);
                    s.onended = () => { try { s.disconnect(); } catch(e){}; resolve(); }; s.start(0);
                } catch (e) { console.warn("playBlobAudio failed", e); resolve(); } 
            });
        },

        wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            text = text || "";
            const words = text.split(' '); let line = ''; let lines = [];
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                if (ctx.measureText(testLine).width > maxWidth && n > 0) { lines.push(line.trim()); line = words[n] + ' '; } else { line = testLine; }
            }
            if (line) lines.push(line.trim());
            let startY = y - ((lines.length - 1) * lineHeight) / 2;
            lines.forEach((l, i) => { if(l) ctx.fillText(l, x, startY + (i * lineHeight)); });
        }
    }
}

// 2. START ALPINE MANUALLY
Alpine.start();
